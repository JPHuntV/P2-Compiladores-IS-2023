package src;
import java_cup.runtime.*;


import java.util.Stack;
import java.util.ArrayList;
import java.util.List;

parser code {:
    //indica si se ha encontrado un error durante el analisis
    Boolean errores = false;

    //estructuras que almacenaran los simbolos de manera temporal durante
    //la creacion de las tablas de simbolos
    ListaElementosTabla listaParametros = new ListaElementosTabla();
    ListaElementosTabla listaVariables = new ListaElementosTabla();

    //estructura que almacena representaciones de las funciones que se hayan encontrado
    List<Funcion> functions = new ArrayList<Funcion>();

    //estructura que almacena las tablas de simbolos definidas
    SymbolTableStack symbolTables = new SymbolTableStack();
    
    /*
    *existeFuncion
    *E::nombre: nombre de la funcion a comprobar su existencia
    *S::Valor booleano que indica la existencia de una funcion
    *R::el nombre de la funcion debe ser un string
    *O::comprobar si una funcion ya fue definidas
    */
    private Boolean existeFuncion(String nombre){
        for(Funcion funcion : functions){
            if(funcion.getName() == nombre){
                return true;
            }
        }
        return false;
    }

    /*
    *getSymbolTableStack
    *E::ninguna
    *S::Tablas de simbolos que han sido creadas
    *R::ningua
    *O::Retornar las tablas de simbolos que han sido creadas
    */
    public SymbolTableStack getSymbolTableStack() {
        return symbolTables;
    }

    
    /*
    *getErrores
    *E::ningua
    *S::valor booleano que indica la existencia de algun error
    *R::ninguna
    *O::indicar si durante el parseo se encontro algun error
    */
    public Boolean getErrores(){
        return errores;
    }

    //instancia del analizador lexico creado en jflex
    Analizador s;
    parser(Analizador s){ this.s=s; }
:}

scan with {: return s.next_token(); :};

/*---------------------------declaraciones------------------------*/

terminal REXC, OR, AND, MULT, LPAREN , RPAREN, MENOS, MAS, ASIG, LBRACKET, RBRACKET, LBRACE, RBRACE, 
    COMA, MENOR, MAYOR, DIV, MENORIGUAL, MAYORIGUAL, EQUAL, NOTEQUAL, POTENCIA, MODULO, INCREMENTO, 
    DECREMENTO, NOT, IF, ELIF, ELSE, WHILE, DO, FOR, RETURN, BREAK, LEER, ESCRIBIR, uminus;

terminal String LITERAL_INT, LITERAL_FLOAT, LITERAL_BOOL, LITERAL_CHAR, LITERAL_STRING;
terminal String IDENTIFIER, DOLLAR, INT, FLOAT, STRING, CHAR, ARRAY, BOOL,MAIN;

non terminal  inicio, programa, main, funciones,expresion, opRelacional, operadorArit, 
    operadorUnario, operadorLogico, expresionAritmetica, expresionRelacional, expresionLogica, 
    expresionRelLog, terminoLogico, operandoArit, operandoRel, array, if, elif, while, doWhile, 
    for, estructuraControl, return, break, argumentos, llamaFuncion, asignacion, sentencia, bloque, 
    parametros, declaraFuncion,tipo, declaraArray, declaraArrayAux, declaraVar, declaraVarNoAsig, getValorArray, 
    setValorArray, lectura, numerico, escritura, literales, argumento,  else, bloqueFunc;


//declaraciones de precedencia
precedence left MAS, MENOS;
precedence left MULT, DIV;
precedence right uminus;
precedence left  POTENCIA, MODULO;
precedence left AND, OR;
precedence nonassoc NOT, REXC;
precedence left DOLLAR;
precedence left CHAR, INT;
precedence left IDENTIFIER;
precedence left LPAREN,LBRACKET;
precedence left expresionLogica;
precedence left expresionRelacional;

//punto de entrada al analisis
start with inicio;

inicio ::= programa:e {:
        System.out.println("El programa ha sido parseado de manera exitosa");
        ASTNode inicio = new ASTNode("inicio");
        inicio.addChild((ASTNode)e);
        RESULT = inicio;
    :};


programa ::= main:e {: 
        ASTNode programa = new ASTNode("programa");
        programa.addChild((ASTNode)e);
        RESULT = programa;
    :}
    | funciones:f main:m 
    | main:m funciones:f 
    | funciones:f main:m funciones:e
    ;


main ::= INT:t MAIN:e LPAREN RPAREN LBRACE bloque:d RBRACE 
    {: 
        
        Boolean existe = false;
        for (Funcion f : functions) {
            if (f.getName().equals(e) && f.getTipoRetorno().equals((String) t )){
                System.out.println("La funcion "+ (String) t +"  " + e + " ya fue declarada");
                errores = true;
                existe = true;
            }
        }
        if(existe == false){
            Funcion newFuncion = new Funcion(e, listaParametros.getParams(), (String) t);
            functions.add(newFuncion);

            SymbolTable symbolTable = new SymbolTable(e,(String) t);

            for (ElementoTabla param : listaParametros.getParams()) {
                symbolTable.addSymbol(param.getName(), param.getType());
            }
            for (ElementoTabla par : listaVariables.getParams()) {
                if (symbolTable.containsSymbol( par.getName())) {
                    System.out.println("El simbolo " +  par.getName() + " ya fue declarado en esta funci√≥n");
                    errores = true;
                }else{
                    symbolTable.addSymbol(par.getName(), par.getType());
                }
            }
             getSymbolTableStack().push(symbolTable);  
        }
        listaVariables  = new ListaElementosTabla();
        listaParametros  = new ListaElementosTabla();
        ASTNode main = new ASTNode("declaraFuncion","main");

        main.addChild((ASTNode) d);
        main.addChild(new ASTNode("dataType",t));
        RESULT = main;    
    :};

funciones ::= funciones:f declaraFuncion:d 
    | declaraFuncion:d 
    ;


expresion ::= expresionLogica:e {:
        ((ASTNode)e).setType("init");
        RESULT = (ASTNode)e;
    :}
    |expresionAritmetica:e {:
        ((ASTNode)e).setType("init");
        RESULT = (ASTNode)e;
    :}
    ;


operadorArit::= MAS:e {:RESULT = e;:}
    | MENOS:e {:RESULT = e;:}
    | MULT :e {:RESULT = e;:}
    | POTENCIA :e {:RESULT = e;:}
    | DIV :e {:RESULT = e;:}
    | MODULO:e {:RESULT = e;:}
    ;


opRelacional ::= MENOR
    | MENORIGUAL
    | MAYOR
    | MAYORIGUAL
    | EQUAL 
    | NOTEQUAL 
    ;


operadorUnario ::= MENOS numerico  %prec uminus
    | INCREMENTO IDENTIFIER 
    | DECREMENTO IDENTIFIER
    ;


operadorLogico ::= AND
    |OR 
    |REXC
    //|NOT
    ;


expresionAritmetica ::= operandoArit:e {:
        RESULT =(ASTNode)e;
    :}
    | expresionAritmetica:ex operadorArit:op operandoArit:e {:
        ASTNode expresionBinaria = new ASTNode("tipo","expresionBinaria");
        ASTNode operador = new ASTNode("operador",op);
        ASTNode res = new ASTNode("res");
        res.addChild((ASTNode)expresionBinaria);
        res.addChild((ASTNode)operador);
        res.addChild((ASTNode)ex);
        res.addChild((ASTNode)e);
        RESULT = res;
    :}
   
    ;





expresionRelacional ::= operandoRel opRelacional operandoRel ;


expresionLogica ::= terminoLogico:t {:
        System.out.println("terminoLogico");
        System.out.println(t);
        ASTNode terminoLogico = new ASTNode("terminoLogico");
        terminoLogico.addChild((ASTNode)t);

        
        RESULT = (ASTNode)t;
    :}
    | expresionLogica operadorLogico terminoLogico
    ;


terminoLogico ::= LITERAL_BOOL:b {:
        System.out.println("literal_bool");
        System.out.println(b);
        ASTNode literal_bool = new ASTNode("literal_bool");
        literal_bool.addChild(new ASTNode(b));
        RESULT = (literal_bool);
    :}
    | LPAREN expresionRelacional RPAREN
    | expresionRelacional
    | NOT terminoLogico
    ;


operandoArit ::= IDENTIFIER
    | LITERAL_STRING:e {:
        System.out.println("literal_string");
        System.out.println(e);
        ASTNode literal_string = new ASTNode("literal_string");
        literal_string.addChild(new ASTNode(e));
        RESULT = literal_string;
    :}
    | LITERAL_INT:e {:
        System.out.println("literal_int");
        System.out.println(e);
        ASTNode literal_int = new ASTNode("literal_int");
        literal_int.addChild(new ASTNode(e));
        RESULT = literal_int;
    :}
    | LITERAL_FLOAT:e {:
        System.out.println("literal_float");
        System.out.println(e);
        ASTNode literal_float = new ASTNode("literal_float");
        literal_float.addChild(new ASTNode(e));
        RESULT = literal_float;
    :}
    | LITERAL_CHAR:e {:
        System.out.println("literal_char");
        System.out.println(e);
        ASTNode literal_char = new ASTNode("literal_char");
        literal_char.addChild(new ASTNode(e));
        RESULT = literal_char;
    :}
    | llamaFuncion   
    | operadorUnario 
    | LBRACKET array RBRACKET
    | getValorArray
    | LPAREN expresionAritmetica RPAREN
    ;


operandoRel ::= operandoArit 
    | LITERAL_BOOL:b 
    ;


literales ::= LITERAL_INT
    |LITERAL_FLOAT
    |LITERAL_BOOL
    |LITERAL_STRING
    |LITERAL_CHAR
    |LBRACKET array RBRACKET
    ;


array ::= expresion  
    | array COMA expresion
    ;


if ::= IF LPAREN expresionRelLog RPAREN LBRACE bloque RBRACE 
    ;


elif ::= ELIF LPAREN expresionRelLog RPAREN LBRACE bloque RBRACE
    | elif ELIF LPAREN expresionRelLog RPAREN LBRACE bloque RBRACE
    ;


else ::= ELSE LBRACE bloque RBRACE;


while ::= WHILE LPAREN expresionRelLog RPAREN LBRACE bloque RBRACE 
    ;


doWhile ::= DO LBRACE bloque RBRACE WHILE LPAREN expresionRelLog RPAREN DOLLAR 
    ;


for ::= FOR LPAREN declaraVar DOLLAR expresionRelLog DOLLAR expresion  RPAREN LBRACE bloque RBRACE 
    ;


estructuraControl ::= if
    |if elif
    |if elif else
    |if  else
    |while
    |doWhile 
    |for
    ;


return ::= RETURN expresion
    |RETURN:r 
    ;


break ::= BREAK;


argumento ::= IDENTIFIER
    | literales
    ;


argumentos ::= argumento
    | argumentos COMA expresion
    ;


llamaFuncion ::= IDENTIFIER  LPAREN RPAREN
    | IDENTIFIER LPAREN argumentos RPAREN 
    | lectura
    | escritura 
    ;


asignacion ::= IDENTIFIER:e ASIG expresion ;


sentencia ::= asignacion DOLLAR 
    | estructuraControl 
    | expresion DOLLAR 
    | declaraArray DOLLAR 
    | declaraVar:a DOLLAR {:
        ASTNode declaraVar = new ASTNode("declaraVar");
        declaraVar.addChild((ASTNode)a);
        RESULT = a;
    :}
    | declaraVarNoAsig:a DOLLAR 
    | return:a DOLLAR 
    | break DOLLAR
    | getValorArray DOLLAR 
    | setValorArray DOLLAR
    | error DOLLAR {: System.out.println("##### Se ha encontrado un error de syntaxis, el parseo continuara"); 
        errores = true;:}
    ;


bloque ::= sentencia:s {:
        ASTNode res = new ASTNode("bloque");
        res.addChild((ASTNode)s);
        RESULT = res;
    :}
    | bloque:b sentencia:s {:
       System.out.println("bloque");
    ASTNode res = new ASTNode("bloque");
    ASTNode bNode = (ASTNode)b;
    for(ASTNode child : bNode.getChildren()){
        res.addChild(child);
    }
    res.addChild((ASTNode)s);
    RESULT = res;
:}
    ;


parametros ::= tipo:t IDENTIFIER:i {: listaParametros.addParameter(new ElementoTabla(i,(String) t));:}
    | parametros:p COMA tipo:t IDENTIFIER:i {:listaParametros.addParameter(new ElementoTabla(i,(String) t));:}
    ;


declaraFuncion ::= tipo:t IDENTIFIER:e LPAREN parametros RPAREN LBRACE bloqueFunc RBRACE 
    {:
        Boolean existe = false;
        for (Funcion f : functions) {
            if (f.getName().equals(e) && f.getTipoRetorno().equals((String) t)) {
                System.out.println("La funcion "+ (String) t +"  " + e + " ya fue declarada");
                errores = true;
                existe = true;
            }
        }
        if(existe == false){
            Funcion newFuncion = new Funcion(e, listaParametros.getParams(), (String) t);
            functions.add(newFuncion);

            SymbolTable symbolTable = new SymbolTable(e,(String) t);

            for (ElementoTabla param : listaParametros.getParams()) {
                symbolTable.addSymbol(param.getName(), param.getType());
            }
            for (ElementoTabla par : listaVariables.getParams()) {
                if (symbolTable.containsSymbol( par.getName())) {
                    System.out.println("Symbolo " +  par.getName() + " ya ha sido declarado en esta funcion");
                    errores = true;
                }else{
                    symbolTable.addSymbol(par.getName(), par.getType());
                }
            }
             getSymbolTableStack().push(symbolTable);
        }
        listaVariables  = new ListaElementosTabla();
        listaParametros  = new ListaElementosTabla();
       
    :}

    | tipo:t IDENTIFIER:e LPAREN RPAREN LBRACE bloque:b RBRACE
    {:
        
        Boolean existe = false;
        for (Funcion f : functions) {
            if (f.getName().equals(e) && f.getTipoRetorno().equals((String) t)) {
                System.out.println("La funcion \""+ (String) t +"  " + e + "\" ya fue declarada previamente");
                errores = true;
                existe = true;
            }
        }
        if(existe == false){
            Funcion newFuncion = new Funcion(e, listaParametros.getParams(), (String) t);
            functions.add(newFuncion);

            SymbolTable symbolTable = new SymbolTable(e,(String) t);

            for (ElementoTabla param : listaParametros.getParams()) {
                symbolTable.addSymbol(param.getName(), param.getType());
            }
            for (ElementoTabla par : listaVariables.getParams()) {
                if (symbolTable.containsSymbol( par.getName())) {
                    System.out.println("Symbolo " +  par.getName() + " ya ha sido declarado en esta funcion");
                    errores = true;
                }else{
                    symbolTable.addSymbol(par.getName(), par.getType());
                }
            }
             getSymbolTableStack().push(symbolTable);
        }
        listaVariables  = new ListaElementosTabla();
        listaParametros  = new ListaElementosTabla();
       
    :};


bloqueFunc ::= bloque;


tipo ::= INT:e {:RESULT = e;:}
    | CHAR:e {: RESULT = e;:}
    |FLOAT:e {:  RESULT = e;:}
    |STRING:e {: RESULT = e;:}
    |ARRAY:e {:  RESULT = e;:}
    |BOOL:e {: RESULT = e; :}
    ;


declaraArray ::=  INT IDENTIFIER LBRACKET LITERAL_INT RBRACKET
    |   CHAR IDENTIFIER LBRACKET LITERAL_INT RBRACKET
    ;


declaraArrayAux ::= LBRACKET LITERAL_INT RBRACKET
    ;

declaraVarNoAsig ::= INT:t IDENTIFIER:i {:
            listaVariables.addParameter(new ElementoTabla(i,(String) t));
        :}  
    | CHAR:t IDENTIFIER:i {:
            listaVariables.addParameter(new ElementoTabla(i,(String) t));
        :}
    | tipo:t IDENTIFIER:i declaraArrayAux {:
            listaVariables.addParameter(new ElementoTabla(i,(String) t));
        :}
    | tipo:t IDENTIFIER:i  {:
            listaVariables.addParameter(new ElementoTabla(i,(String) t));
        :}
    ;

declaraVar ::= 
       INT:t IDENTIFIER:i ASIG expresion:e {:
           listaVariables.addParameter(new ElementoTabla(i,(String) t));
           ASTNode declaraVar = new ASTNode("declaraVar", i);
           declaraVar.addChild( new ASTNode("dataType", t) );
           declaraVar.addChild( (ASTNode)e);
           RESULT = declaraVar;

       :}  
    |
    CHAR:t IDENTIFIER:i  ASIG expresion:e {:
           listaVariables.addParameter(new ElementoTabla(i,(String) t));
           ASTNode declaraVar = new ASTNode("declaraVar", i);
           declaraVar.addChild( new ASTNode("dataType", t) );
           declaraVar.addChild( (ASTNode)e);
           RESULT = declaraVar;

       :}
    | tipo:t IDENTIFIER:i declaraArrayAux ASIG expresion:e{:
           listaVariables.addParameter(new ElementoTabla(i,(String) t));
           ASTNode declaraVar = new ASTNode("declaraVar", i);
           declaraVar.addChild( new ASTNode("dataType", t) );
           declaraVar.addChild( (ASTNode)e);
           RESULT = declaraVar;

       :}
    | tipo:t IDENTIFIER:i ASIG expresion:e {:
           listaVariables.addParameter(new ElementoTabla(i,(String) t));
           ASTNode declaraVar = new ASTNode("declaraVar", i);
           declaraVar.addChild( new ASTNode("dataType", t) );
           declaraVar.addChild( (ASTNode)e);
           RESULT = declaraVar;

       :}
    ;


getValorArray ::= IDENTIFIER declaraArrayAux 
    ;


setValorArray ::= getValorArray ASIG expresion   ;


lectura ::= LEER LPAREN numerico RPAREN ;


numerico ::= LITERAL_INT | LITERAL_FLOAT  ;


escritura ::= ESCRIBIR LPAREN expresion RPAREN ; 


