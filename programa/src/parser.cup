package src;
import java_cup.runtime.*;


import java.util.Stack;
import java.util.ArrayList;
import java.util.List;

parser code {:
    //indica si se ha encontrado un error durante el analisis
    Boolean errores = false;

    //estructuras que almacenaran los simbolos de manera temporal durante
    //la creacion de las tablas de simbolos
    ListaElementosTabla listaParametros = new ListaElementosTabla();
    ListaElementosTabla listaVariables = new ListaElementosTabla();

    //estructura que almacena representaciones de las funciones que se hayan encontrado
    List<Funcion> functions = new ArrayList<Funcion>();

    //estructura que almacena las tablas de simbolos definidas
    SymbolTableStack symbolTables = new SymbolTableStack();
    
    /*
    *existeFuncion
    *E::nombre: nombre de la funcion a comprobar su existencia
    *S::Valor booleano que indica la existencia de una funcion
    *R::el nombre de la funcion debe ser un string
    *O::comprobar si una funcion ya fue definidas
    */
    private Boolean existeFuncion(String nombre){
        for(Funcion funcion : functions){
            if(funcion.getName() == nombre){
                return true;
            }
        }
        return false;
    }

    /*
    *getSymbolTableStack
    *E::ninguna
    *S::Tablas de simbolos que han sido creadas
    *R::ningua
    *O::Retornar las tablas de simbolos que han sido creadas
    */
    public SymbolTableStack getSymbolTableStack() {
        return symbolTables;
    }

    
    /*
    *getErrores
    *E::ningua
    *S::valor booleano que indica la existencia de algun error
    *R::ninguna
    *O::indicar si durante el parseo se encontro algun error
    */
    public Boolean getErrores(){
        return errores;
    }

//########################################################################


    public boolean checkDeclaraVar(String tipo, ASTNode node){
        String valor = node.getChildren().get(0).getType();
        System.out.println("testing ,"+tipo+",    "+valor);
        switch (valor) {
            case "literal_int":
                return tipo.equals("int");
            case "literal_bool":
                return tipo.equals("bool");
            case "literal_string":
                return tipo.equals("String");
            case "literal_float":
                return tipo.equals("float");
            case "literal_char":
                return tipo.equals("char");
            case "IDENTIFIER":
                String varName = node.getChildren().get(0).getChildren().get(0).getType();
                String varTipo = simboloValido(varName);
                return tipo.equals(varTipo);
            default:
                // Handle unsupported type
                return false;
        }
    }
    public String simboloValido(String varName){ 
        System.out.println(varName);
        String varTipo = listaParametros.existe(varName);
        String varTipo1 = listaVariables.existe(varName);
        System.out.println("---------------");
        System.out.println(varTipo);
        System.out.println(varTipo1);
        if(varTipo != null){
            return varTipo;
        }    
        else if(varTipo1 != null){
            return varTipo1;
        }else{
            System.out.println("Error: "+varName+" no coincide con ningun simbolo declarado previamente");
            return null;
        }

    }


    //instancia del analizador lexico creado en jflex
    Analizador s;
    parser(Analizador s){ this.s=s; }
:}

scan with {: return s.next_token(); :};

/*---------------------------declaraciones------------------------*/

terminal REXC, OR, AND, MULT, LPAREN , RPAREN, MENOS, MAS, ASIG, LBRACKET, RBRACKET, LBRACE, RBRACE, 
    COMA, MENOR, MAYOR, DIV, MENORIGUAL, MAYORIGUAL, EQUAL, NOTEQUAL, POTENCIA, MODULO, INCREMENTO, 
    DECREMENTO, NOT, IF, ELIF, ELSE, WHILE, DO, FOR, RETURN, BREAK, LEER, ESCRIBIR, uminus;

terminal String LITERAL_INT, LITERAL_FLOAT, LITERAL_BOOL, LITERAL_CHAR, LITERAL_STRING;
terminal String IDENTIFIER, DOLLAR, INT, FLOAT, STRING, CHAR, ARRAY, BOOL,MAIN;

non terminal  inicio, programa, main, funciones,expresion, opRelacional, operadorArit, 
    operadorUnario, operadorLogico, expresionAritmetica, expresionRelacional, expresionLogica, 
    terminoLogico, operandoArit, operandoRel, array, if, elif, while, doWhile, 
    for, estructuraControl, return, break, argumentos, llamaFuncion, asignacion, sentencia, bloque, 
    parametros, declaraFuncion,tipo, declaraArray, declaraArrayAux, declaraVar, declaraVarNoAsig, getValorArray, 
    setValorArray, lectura, numerico, escritura, literales, argumento,  else;


//declaraciones de precedencia
precedence left MAS, MENOS;
precedence left MULT, DIV;
precedence right uminus;
precedence left  POTENCIA, MODULO;
precedence left AND, OR;
precedence nonassoc NOT, REXC;
precedence left DOLLAR;
precedence left CHAR, INT;
precedence left IDENTIFIER;
precedence left LPAREN,LBRACKET;
precedence left expresionLogica;
precedence left expresionRelacional;

//punto de entrada al analisis
start with inicio;

inicio ::= programa:e {:
        System.out.println("El programa ha sido parseado de manera exitosa");
        ASTNode inicio = new ASTNode("inicio");
        inicio.addChild((ASTNode)e);
        RESULT = inicio;
    :};


programa ::= main:e {: 
        ASTNode programa = new ASTNode("programa");
        programa.addChild((ASTNode)e);
        RESULT = programa;
    :}
    | funciones:f main:m {:
        ((ASTNode)f).setType("programa");
        ((ASTNode)f).addChild((ASTNode)m);
        RESULT = f;
    :}
    | main:m funciones:f {: 
        ASTNode programa = new ASTNode("programa");
        programa.addChild((ASTNode)m);
        ASTNode bNode = (ASTNode)f;
        for(ASTNode child : bNode.getChildren()){
            programa.addChild(child);
        }
        RESULT = programa;
    :}
    | funciones:f main:m funciones:e{: 
        ASTNode programa = new ASTNode("programa");
        ASTNode bNode = (ASTNode)f;
        for(ASTNode child : bNode.getChildren()){
            programa.addChild(child);
        }
        programa.addChild((ASTNode)m);
        bNode = (ASTNode)e;
        for(ASTNode child : bNode.getChildren()){
            programa.addChild(child);
        }
        RESULT = programa;
    :}
    ;


main ::= INT:t MAIN:e LPAREN RPAREN LBRACE bloque:d RBRACE 
    {: 
        
        Boolean existe = false;
        for (Funcion f : functions) {
            if (f.getName().equals(e) && f.getTipoRetorno().equals((String) t )){
                System.out.println("La funcion "+ (String) t +"  " + e + " ya fue declarada");
                errores = true;
                existe = true;
            }
        }
        if(existe == false){
            Funcion newFuncion = new Funcion(e, listaParametros.getParams(), (String) t);
            functions.add(newFuncion);

            SymbolTable symbolTable = new SymbolTable(e,(String) t);

            for (ElementoTabla param : listaParametros.getParams()) {
                symbolTable.addSymbol(param.getName(), param.getType());
            }
            for (ElementoTabla par : listaVariables.getParams()) {
                if (symbolTable.containsSymbol( par.getName())) {
                    System.out.println("El simbolo " +  par.getName() + " ya fue declarado en esta funci√≥n");
                    
                    errores = true;
                }else{
                    symbolTable.addSymbol(par.getName(), par.getType());
                }
            }
             getSymbolTableStack().push(symbolTable);  
        }
        listaVariables  = new ListaElementosTabla();
        listaParametros  = new ListaElementosTabla();
        ASTNode main = new ASTNode("declaraFuncion","main");

        main.addChild((ASTNode) d);
        main.addChild(new ASTNode("dataType",t));
        RESULT = main;    
    :};

funciones ::= funciones:f declaraFuncion:d {:
        System.out.println("declaraFuncion");
        ASTNode res = new ASTNode("declaraFuncion");
        ASTNode bNode = (ASTNode)f;
        for(ASTNode child : bNode.getChildren()){
            res.addChild(child);
        }
        res.addChild((ASTNode)d);
        RESULT = res;
    :}
    | declaraFuncion:d {:
        ASTNode res = new ASTNode("declaraFuncion");
        res.addChild((ASTNode)d);
        RESULT = res;

        
    :}
    ;


expresion ::= expresionLogica:e {:
        ASTNode res = new ASTNode("init");
        res.addChild((ASTNode)e);
        RESULT = res;
    :}
    |expresionAritmetica:e {:
        ASTNode res = new ASTNode("init");
        res.addChild((ASTNode)e);
        RESULT = res;
    :}
    ;



operadorArit::= MAS:e {:RESULT = e;:}
    | MENOS:e {:RESULT = e;:}
    | MULT :e {:RESULT = e;:}
    | POTENCIA :e {:RESULT = e;:}
    | DIV :e {:RESULT = e;:}
    | MODULO:e {:RESULT = e;:}
    ;


opRelacional ::= MENOR:e {:RESULT = e;:}
    | MENORIGUAL:e {:RESULT = e;:}
    | MAYOR:e {:RESULT = e;:}
    | MAYORIGUAL:e {:RESULT = e;:}
    | EQUAL:e {:RESULT = e;:}
    | NOTEQUAL:e {:RESULT = e;:}
    ;


operadorUnario ::= MENOS:op numerico:e  {:
        System.out.println("operador unario");
        ASTNode expresionUnaria = new ASTNode("tipo","expresionUnaria");
        ASTNode operador = new ASTNode("operador",op);
        ASTNode res = new ASTNode("res");
        res.addChild((ASTNode)expresionUnaria);
        res.addChild((ASTNode)operador);
        res.addChild(new ASTNode("value", (ASTNode)e));
        RESULT = res;
    :} %prec uminus
    |MENOS:op IDENTIFIER:e  {:
        System.out.println("operador unario");
        ASTNode expresionUnaria = new ASTNode("tipo","expresionUnaria");
        ASTNode operador = new ASTNode("operador",op);
        ASTNode res = new ASTNode("res");
        res.addChild((ASTNode)expresionUnaria);
        res.addChild((ASTNode)operador);
        res.addChild(new ASTNode("value", e));
        RESULT = res;
    :} %prec uminus
    | INCREMENTO:op IDENTIFIER:e {:
        System.out.println("operador unario");
        ASTNode expresionUnaria = new ASTNode("tipo","expresionUnaria");
        ASTNode operador = new ASTNode("operador",op);
        ASTNode res = new ASTNode("res");
        res.addChild((ASTNode)expresionUnaria);
        res.addChild((ASTNode)operador);
        res.addChild(new ASTNode("value", e));
        RESULT = res;
    :}
    | DECREMENTO:op IDENTIFIER:e{:
        System.out.println("operador unario");
        ASTNode expresionUnaria = new ASTNode("tipo","expresionUnaria");
        ASTNode operador = new ASTNode("operador",op);
        ASTNode res = new ASTNode("res");
        res.addChild((ASTNode)expresionUnaria);
        res.addChild((ASTNode)operador);
        res.addChild(new ASTNode("value", e));
        RESULT = res;
    :}
    ;


operadorLogico ::= AND:e {:RESULT = e;:}
    |OR:e {:RESULT = e;:} 
    |REXC:e {:RESULT = e;:}
    //|NOT
    ;



expresionAritmetica ::= operandoArit:e {:
        RESULT =(ASTNode)e;
    :}
    | expresionAritmetica:ex operadorArit:op operandoArit:e {:
        ASTNode expresionBinaria = new ASTNode("tipo","expresionAritmetica");
        ASTNode operador = new ASTNode("operador",op);
        ASTNode res = new ASTNode("expresionBinaria");
        res.addChild((ASTNode)expresionBinaria);
        res.addChild((ASTNode)operador);
        res.addChild((ASTNode)ex);
        res.addChild((ASTNode)e);
        RESULT = res;
    :}
   
    ;





expresionRelacional ::= operandoRel:a opRelacional:op operandoRel:b {:
    ASTNode res = new ASTNode("tipo","expresionRelacional");
    res.addChild(new ASTNode("operador",op));
    res.addChild((ASTNode)a);
    res.addChild((ASTNode)b);
    RESULT = res;
:}

 ;


expresionLogica ::= terminoLogico:t {:
        System.out.println("terminoLogico");
        System.out.println(t);
        ASTNode terminoLogico = new ASTNode("terminoLogico");
        terminoLogico.addChild((ASTNode)t);
        RESULT = (ASTNode)t;
    :}
    | expresionLogica:ex operadorLogico:op terminoLogico:e{:
        ASTNode res = new ASTNode("res");
        res.addChild(new ASTNode("tipo","expresionLogica"));
        res.addChild(new ASTNode("operador",op));
        res.addChild((ASTNode)ex);
        res.addChild((ASTNode)e);
        RESULT = res;
    :}
    ;


terminoLogico ::= LITERAL_BOOL:b {:
        ASTNode literal_bool = new ASTNode("literal_bool");
        literal_bool.addChild(new ASTNode(b));
        RESULT = (literal_bool);
    :}
    | LPAREN expresionRelacional:r RPAREN {:
        ASTNode expresionRelacional = new ASTNode("expresionBinaria");
        expresionRelacional.addChild((ASTNode)r);
        RESULT = expresionRelacional;
    :}
    | expresionRelacional:r {:
        System.out.println("expresionBinaria");
        System.out.println(r);
        ASTNode expresionRelacional = new ASTNode("expresionBinaria");
        expresionRelacional.addChild((ASTNode)r);
        RESULT = expresionRelacional;
    :}
    | NOT:op terminoLogico:t{:
        ASTNode notOp = new ASTNode("notOp");
        notOp.addChild((ASTNode)t);
        ASTNode res =  new ASTNode("res");
        res.addChild(notOp);
        RESULT = (res);
    :}
    ;


operandoArit ::= 
    IDENTIFIER:e {:
        System.out.println("IDENTIFIER");
        System.out.println(e);
        ASTNode IDENTIFIER = new ASTNode("IDENTIFIER");
        IDENTIFIER.addChild(new ASTNode(e));
        RESULT = IDENTIFIER;
    :}
    | LITERAL_STRING:e {:
        System.out.println("literal_string");
        System.out.println(e);
        ASTNode literal_string = new ASTNode("literal_string");
        literal_string.addChild(new ASTNode(e));
        RESULT = literal_string;
    :}
    | LITERAL_INT:e {:
        System.out.println("literal_int");
        System.out.println(e);
        ASTNode literal_int = new ASTNode("literal_int");
        literal_int.addChild(new ASTNode(e));
        RESULT = literal_int;
    :}
    | LITERAL_FLOAT:e {:
        System.out.println("literal_float");
        System.out.println(e);
        ASTNode literal_float = new ASTNode("literal_float");
        literal_float.addChild(new ASTNode(e));
        RESULT = literal_float;
    :}
    | LITERAL_CHAR:e {:
        System.out.println("literal_char");
        System.out.println(e);
        ASTNode literal_char = new ASTNode("literal_char");
        literal_char.addChild(new ASTNode(e));
        RESULT = literal_char;
    :}
    | llamaFuncion:e{:
        System.out.println("llamaFuncion");
        System.out.println(e);
        ASTNode llamaFuncion = new ASTNode("llamaFuncion");
        llamaFuncion.addChild((ASTNode)e);
        RESULT = llamaFuncion;
    :}   
    | operadorUnario:e{:
        ((ASTNode)e).setType("operadorUnario");
        RESULT = ((ASTNode)e);
    :}  
    | LBRACKET array:e RBRACKET{:
        RESULT = e;
    :}
    | getValorArray:e {:
        RESULT = ((ASTNode)e).getChildren().get(0);
    :}
    | LPAREN expresionAritmetica:e RPAREN {:
        RESULT = e;
    :}
    ;


operandoRel ::= operandoArit:e {:RESULT = e;:} 
    | LITERAL_BOOL:b {:
        System.out.println("literal_bool");
        System.out.println(b);
        ASTNode literal_bool = new ASTNode("literal_bool");
        literal_bool.addChild(new ASTNode(b));
        RESULT = (literal_bool);
    :}
    ;


literales ::= LITERAL_INT:e {:RESULT = e;:}
    |LITERAL_FLOAT:e {:RESULT = e;:}
    |LITERAL_BOOL:e {:RESULT = e;:}
    |LITERAL_STRING:e {:RESULT = e;:}
    |LITERAL_CHAR:e {:RESULT = e;:}
    |LBRACKET array:e RBRACKET {:RESULT = e;:}
    ;


array ::= expresion:a {:
        ASTNode res = new ASTNode("array");
        res.addChild((ASTNode)a);
        RESULT = res;
    :}  
    | array:a COMA expresion:e{:
        System.out.println("array");
        ASTNode res = new ASTNode("array");
        ASTNode bNode = (ASTNode)a;
        for(ASTNode child : bNode.getChildren()){
            res.addChild(child);
        }
        res.addChild((ASTNode)e);
        RESULT = res;
    :}
    ;


if ::= IF LPAREN expresionLogica:exp RPAREN LBRACE bloque:b RBRACE {:
        ASTNode res =  new ASTNode("estructuraControl");
        res.addChild(new ASTNode("tipo","ifStm"));
        res.addChild(new ASTNode("eval", (ASTNode)exp));
        res.addChild(new ASTNode("body",(ASTNode)b));
        RESULT = res;

    :}
    ;


elif ::= ELIF LPAREN expresionLogica:exp RPAREN LBRACE bloque:b RBRACE{:
        ASTNode res =  new ASTNode("estructuraControl");
        res.addChild(new ASTNode("tipo","elifStm"));
        res.addChild(new ASTNode("eval", (ASTNode)exp));
        res.addChild(new ASTNode("body",(ASTNode)b));
        RESULT = res;

    :}
    | elif:e ELIF LPAREN expresionLogica:exp RPAREN LBRACE bloque:b RBRACE{:
        ASTNode res =  new ASTNode("estructuraControl");
        res.addChild(new ASTNode("tipo","elifStm"));
        res.addChild(new ASTNode("eval", (ASTNode)exp));
        ((ASTNode)b).addChild(new ASTNode("alternate",null));
        res.addChild(new ASTNode("body",(ASTNode)b));
        RESULT = res;

        ((ASTNode)e).addChild(new ASTNode("alternate",res));
        RESULT = e;
    :}
    ;


else ::= ELSE LBRACE bloque:b RBRACE {:
        ASTNode res =  new ASTNode("estructuraControl");
        res.addChild(new ASTNode("tipo","elseStm"));
        res.addChild(new ASTNode("body",(ASTNode)b));
        RESULT = res;

    :}
;


while ::= WHILE LPAREN expresionLogica:exp RPAREN LBRACE bloque:b RBRACE {:
        ASTNode res =  new ASTNode("estructuraControl");
        res.addChild(new ASTNode("tipo","whileStm"));
        res.addChild(new ASTNode("eval", (ASTNode)exp));
        res.addChild(new ASTNode("body",(ASTNode)b));
        RESULT = res;
    :}
    ;


doWhile ::= DO LBRACE bloque:b RBRACE WHILE LPAREN expresionLogica:exp RPAREN DOLLAR {:
        ASTNode res =  new ASTNode("estructuraControl");
        res.addChild(new ASTNode("tipo","doWhileStm"));
        res.addChild(new ASTNode("body",(ASTNode)b));
        res.addChild(new ASTNode("eval", (ASTNode)exp));
        RESULT = res;
    :}
    ;


for ::= FOR LPAREN declaraVar:d DOLLAR expresionLogica:exp DOLLAR expresion:e  RPAREN LBRACE bloque:b RBRACE {:
        ASTNode res =  new ASTNode("estructuraControl");
        res.addChild(new ASTNode("tipo","forStm"));
        res.addChild(new ASTNode("init", (ASTNode)d));
        res.addChild(new ASTNode("eval", (ASTNode)exp));
        res.addChild(new ASTNode("update", (ASTNode)e));
        res.addChild(new ASTNode("body",(ASTNode)b));
        RESULT = res;
    :}
    ;


estructuraControl ::= if:f{:
        ((ASTNode)f).addChild(new ASTNode("alternate", null));
        RESULT = f;
    :}
    |if:f elif:e {:
        ((ASTNode)f).addChild(new ASTNode("alternate",(ASTNode) e));
        RESULT = f;
    :}
    |if:f elif:ef else:e {:
        ((ASTNode)f).addChild(new ASTNode("alternate",(ASTNode) ef));
        ((ASTNode)f).addChild(new ASTNode("alternateElse",(ASTNode) e));
        RESULT = f;
    :}
    |if:f  else:e {:
        ((ASTNode)f).addChild(new ASTNode("alternateElse",(ASTNode) e));
        RESULT = f;
    :}
    |while:w {:
        RESULT = w;
    :}
    |doWhile:dw {:
        RESULT = dw;
    :}
    |for:f {:
        RESULT = f;
    :}
    ;


return ::= RETURN:r expresion:e{:
        ((ASTNode)e).setType("value");
        RESULT = ((ASTNode)e);
    :}
    |RETURN:r {:
        ASTNode e = new ASTNode("value", null);
        RESULT = e;
    :}
    ;


break ::= BREAK:r //{:    :}

;


argumento ::= IDENTIFIER:e {:RESULT = e;:}
    | literales:e {:RESULT = e;:}
    ;


argumentos ::= argumento:a {:
        ASTNode res = new ASTNode("argumentos");
        res.addChild(new ASTNode((String)a));
        RESULT = res;
    :}
    | argumentos:a COMA argumento:e {:
        ASTNode res = new ASTNode("argumentos");
        ASTNode bNode = (ASTNode)a;
        for(ASTNode child : bNode.getChildren()){
            res.addChild(child);
        }
        res.addChild(new ASTNode((String)e));
        RESULT = res;
    :}
    ;


llamaFuncion ::= IDENTIFIER:e  LPAREN RPAREN {:
        ASTNode llamadaFuncion = new ASTNode("llamadaFuncion", e);
        RESULT = llamadaFuncion;
    :}
    | IDENTIFIER:e LPAREN argumentos:a RPAREN {:
        ASTNode llamadaFuncion = new ASTNode("llamadaFuncion", e);
        llamadaFuncion.addChild((ASTNode)a);
        RESULT = llamadaFuncion;
    :}
    | lectura:l {:
        ASTNode lectura = new ASTNode("lectura", l);
        RESULT = lectura;
    :}
    | escritura:e{:
        ASTNode escritura = new ASTNode("escritura", e);
        RESULT = escritura;
    :}
    ;


asignacion ::= IDENTIFIER:e ASIG expresion:ex{:
        ASTNode asignacion = new ASTNode("asignacion", e);
        asignacion.addChild((ASTNode)ex);
        RESULT = asignacion;
    :} 

;


sentencia ::= 
    asignacion:a DOLLAR{:
        RESULT = (ASTNode)a;
    :} 
    | estructuraControl:a {:
        ASTNode estructuraControl = new ASTNode("estructuraControl");
        estructuraControl.addChild((ASTNode)a);
        RESULT = (ASTNode)a;
    :}
    | expresion:e DOLLAR{:
        ((ASTNode)e).setType("expresion");
        RESULT = (ASTNode)e;
    :} 
    | declaraArray:a DOLLAR {:
        RESULT = (ASTNode)a;
    :}
    | declaraVar:a DOLLAR {:
        ASTNode declaraVar = new ASTNode("declaraVar");
        declaraVar.addChild((ASTNode)a);
        RESULT = a;
    :}
    | declaraVarNoAsig:a DOLLAR {:
        ASTNode declaraVar = new ASTNode("declaraVar");
        declaraVar.addChild((ASTNode)a);
        RESULT = a;
    :}
    | return:a DOLLAR {:
        ASTNode returnStm = new ASTNode("returnStm");
        returnStm.addChild((ASTNode)a);
        RESULT = returnStm;
    :}
    | break DOLLAR{:
        ASTNode breakStm = new ASTNode("breakStm");
        RESULT = breakStm;
    :}
    | getValorArray:e DOLLAR {:
        RESULT = e;
    :}
    | setValorArray:e DOLLAR {:
        RESULT = e;
    :}
    | error DOLLAR {: System.out.println("##### Se ha encontrado un error de syntaxis, el parseo continuara"); 
        errores = true;:}
    ;


bloque ::= 
    sentencia:s {:
        ASTNode res = new ASTNode("bloque");
        res.addChild((ASTNode)s);
        RESULT = res;
    :}
    | bloque:b sentencia:s {:
        System.out.println("bloque");
        ASTNode res = new ASTNode("bloque");
        ASTNode bNode = (ASTNode)b;
        for(ASTNode child : bNode.getChildren()){
            res.addChild(child);
        }
        res.addChild((ASTNode)s);
        RESULT = res;
    :}
    ;


parametros ::= 
    tipo:t IDENTIFIER:i {: 
        listaParametros.addParameter(new ElementoTabla(i,(String) t));
        ASTNode res = new ASTNode("parametros");
        res.addChild(new ASTNode((String)t,(String)i));
        RESULT = res;
    :}
    | parametros:p COMA tipo:t IDENTIFIER:i {:
        listaParametros.addParameter(new ElementoTabla(i,(String) t));
        ASTNode res = new ASTNode("parametros");
        ASTNode bNode = (ASTNode)p;
        for(ASTNode child : bNode.getChildren()){
            res.addChild(child);
        }
        res.addChild(new ASTNode((String)t,(String)i));
        RESULT = res;
    :}
    ;


declaraFuncion ::= tipo:t IDENTIFIER:e LPAREN parametros:p RPAREN LBRACE bloque:b RBRACE 
    {:
        Boolean existe = false;
        for (Funcion f : functions) {
            if (f.getName().equals(e) && f.getTipoRetorno().equals((String) t)) {
                System.out.println("La funcion "+ (String) t +"  " + e + " ya fue declarada");
                errores = true;
                existe = true;
            }
        }
        if(existe == false){
            Funcion newFuncion = new Funcion(e, listaParametros.getParams(), (String) t);
            functions.add(newFuncion);

            SymbolTable symbolTable = new SymbolTable(e,(String) t);

            for (ElementoTabla param : listaParametros.getParams()) {
                symbolTable.addSymbol(param.getName(), param.getType());
            }
            for (ElementoTabla par : listaVariables.getParams()) {
                if (symbolTable.containsSymbol( par.getName())) {
                    System.out.println("Symbolo " +  par.getName() + " ya ha sido declarado en esta funcion");
                    errores = true;
                }else{
                    symbolTable.addSymbol(par.getName(), par.getType());
                }
            }
             getSymbolTableStack().push(symbolTable);
        }
        listaVariables  = new ListaElementosTabla();
        listaParametros  = new ListaElementosTabla();
        ASTNode main = new ASTNode("declaraFuncion",e);
        main.addChild((ASTNode) p);
        main.addChild((ASTNode) b);
        main.addChild(new ASTNode("dataType",t));
        RESULT = main; 
    :}

    | tipo:t IDENTIFIER:e LPAREN RPAREN LBRACE bloque:b RBRACE
    {:
        
        Boolean existe = false;
        for (Funcion f : functions) {
            if (f.getName().equals(e) && f.getTipoRetorno().equals((String) t)) {
                System.out.println("La funcion \""+ (String) t +"  " + e + "\" ya fue declarada previamente");
                errores = true;
                existe = true;
            }
        }
        if(existe == false){
            Funcion newFuncion = new Funcion(e, listaParametros.getParams(), (String) t);
            functions.add(newFuncion);

            SymbolTable symbolTable = new SymbolTable(e,(String) t);

            for (ElementoTabla param : listaParametros.getParams()) {
                symbolTable.addSymbol(param.getName(), param.getType());
            }
            for (ElementoTabla par : listaVariables.getParams()) {
                if (symbolTable.containsSymbol( par.getName())) {
                    System.out.println("Symbolo " +  par.getName() + " ya ha sido declarado en esta funcion");
                    errores = true;
                }else{
                    symbolTable.addSymbol(par.getName(), par.getType());
                }
            }
             getSymbolTableStack().push(symbolTable);
        }
        listaVariables  = new ListaElementosTabla();
        listaParametros  = new ListaElementosTabla();
        ASTNode main = new ASTNode("declaraFuncion",e);
        main.addChild((ASTNode) b);
        main.addChild(new ASTNode("dataType",t));
        RESULT = main; 
    :};





tipo ::= INT:e {:RESULT = e;:}
    | CHAR:e {: RESULT = e;:}
    |FLOAT:e {:  RESULT = e;:}
    |STRING:e {: RESULT = e;:}
    |ARRAY:e {:  RESULT = e;:}
    |BOOL:e {: RESULT = e; :}
    ;


declaraArray ::=  
    INT:t IDENTIFIER:i LBRACKET LITERAL_INT:s RBRACKET {:
        listaVariables.addParameter(new ElementoTabla(i,(String) t));
        ASTNode declaraVar = new ASTNode("declaraArray", i);
        declaraVar.addChild( new ASTNode("dataType", t) );
        declaraVar.addChild(new ASTNode("size",s));
        RESULT = declaraVar;
    :}
    |CHAR:t IDENTIFIER:i LBRACKET LITERAL_INT:s RBRACKET{:
        listaVariables.addParameter(new ElementoTabla(i,(String) t));
        ASTNode declaraVar = new ASTNode("declaraVar", i);
        declaraVar.addChild( new ASTNode("dataType", t) );
        declaraVar.addChild(new ASTNode("size",s));
        RESULT = declaraVar;
    :}
    ;


declaraArrayAux ::= LBRACKET LITERAL_INT:e RBRACKET{:
        RESULT = e;
    :}
    ;

declaraVarNoAsig ::= 
    INT:t IDENTIFIER:i {:
            listaVariables.addParameter(new ElementoTabla(i,(String) t));
            ASTNode declaraVar = new ASTNode("declaraVar", i);
            declaraVar.addChild( new ASTNode("dataType", t) );
            RESULT = declaraVar;
        :}  
    | CHAR:t IDENTIFIER:i {:
            listaVariables.addParameter(new ElementoTabla(i,(String) t));
            ASTNode declaraVar = new ASTNode("declaraVar", i);
            declaraVar.addChild( new ASTNode("dataType", t) );
            RESULT = declaraVar;
        :}
    | tipo:t IDENTIFIER:i  {:
            listaVariables.addParameter(new ElementoTabla(i,(String) t));
            ASTNode declaraVar = new ASTNode("declaraVar", i);
            declaraVar.addChild( new ASTNode("dataType", t) );
            RESULT = declaraVar;
        :}
    ;

declaraVar ::= 
       INT:t IDENTIFIER:i ASIG expresion:e {:

            System.out.println("tipo variable: "+t);
            System.out.println("tipo valor: "+((ASTNode)e).getChildren().get(0).getType());
            if(checkDeclaraVar(t,(ASTNode)e)){
                listaVariables.addParameter(new ElementoTabla(i,(String) t));
            }else{
                System.out.println("Error al declarar variable "+i+": El tipo de la variable ("+t+") no coincide con el tipo del valor asignado o este no ha sido declarado");
            }
           ASTNode declaraVar = new ASTNode("declaraVar", i);
           declaraVar.addChild( new ASTNode("dataType", t) );
           declaraVar.addChild( (ASTNode)e);
           RESULT = declaraVar;

       :}  
    |
    CHAR:t IDENTIFIER:i  ASIG expresion:e {:
           System.out.println("tipo variable: "+t);
            System.out.println("tipo valor: "+((ASTNode)e).getChildren().get(0).getType());
            if(checkDeclaraVar((String)t,(ASTNode)e)){
                listaVariables.addParameter(new ElementoTabla(i,(String) t));
            }else{
                System.out.println("Error al declarar variable "+i+": El tipo de la variable ("+t+") no coincide con el tipo del valor asignado o este no ha sido declarado");
            }
           ASTNode declaraVar = new ASTNode("declaraVar", i);
           declaraVar.addChild( new ASTNode("dataType", t) );
           declaraVar.addChild( (ASTNode)e);
           RESULT = declaraVar;
       :}
    | declaraArray:d ASIG LBRACKET array:e RBRACKET{:
           ((ASTNode)d).addChild( (ASTNode)e);
           RESULT = (ASTNode)d;
       :}
    | tipo:t IDENTIFIER:i ASIG expresion:e {:
           System.out.println("tipo variable: "+t);
            System.out.println("tipo valor: "+((ASTNode)e).getChildren().get(0).getType());
            if(checkDeclaraVar((String)t,(ASTNode)e)){
                listaVariables.addParameter(new ElementoTabla(i,(String) t));
            }else{
                System.out.println("Error al declarar variable "+i+": El tipo de la variable ("+t+") no coincide con el tipo del valor asignado o este no ha sido declarado");
            }
           ASTNode declaraVar = new ASTNode("declaraVar", i);
           declaraVar.addChild( new ASTNode("dataType", t) );
           declaraVar.addChild( (ASTNode)e);
           RESULT = declaraVar;

       :}
    ;


getValorArray ::= IDENTIFIER:e declaraArrayAux:d{:
        ASTNode res = new ASTNode("res");
        ASTNode getValorArray = new ASTNode("getValorArray",e);
        getValorArray.addChild(new ASTNode("posicion",d));
        res.addChild(getValorArray);
        RESULT = res;
    :}
    ;


setValorArray ::= getValorArray:e ASIG expresion:ex{:
        ASTNode setValorArray = ((ASTNode)e).getChildren().get(0);
        setValorArray.setType("setValorArray");
        setValorArray.addChild(new ASTNode("value", (ASTNode)ex));
        RESULT = setValorArray;
    :}

   ;


lectura ::= 
    LEER LPAREN numerico:n RPAREN{:
        RESULT = n;
    :}
    | LEER LPAREN IDENTIFIER:n RPAREN{:
        RESULT = n;
    :}
    ;



numerico ::= LITERAL_INT:e {:
        System.out.println("literal_int");
        System.out.println(e);
        ASTNode literal_int = new ASTNode("literal_int");
        literal_int.addChild(new ASTNode(e));
        RESULT = literal_int;
    :}
    | LITERAL_FLOAT:e {:
        System.out.println("literal_float");
        System.out.println(e);
        ASTNode literal_int = new ASTNode("literal_float");
        literal_int.addChild(new ASTNode(e));
        RESULT = literal_int;
    :}
    ;


escritura ::= ESCRIBIR LPAREN expresion:e RPAREN{:
        RESULT = e;
    :} ; 


