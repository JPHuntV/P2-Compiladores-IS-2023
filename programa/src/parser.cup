package src;
import java_cup.runtime.*;


import java.util.Stack;
import java.util.ArrayList;
import java.util.List;

parser code {:
    //indica si se ha encontrado un error durante el analisis
    Boolean errores = false;

    //estructuras que almacenaran los simbolos de manera temporal durante
    //la creacion de las tablas de simbolos
    ListaElementosTabla listaParametros = new ListaElementosTabla();
    ListaElementosTabla listaVariables = new ListaElementosTabla();

    //estructura que almacena representaciones de las funciones que se hayan encontrado
    List<Funcion> functions = new ArrayList<Funcion>();

    //estructura que almacena las tablas de simbolos definidas
    SymbolTableStack symbolTables = new SymbolTableStack();
    
    /*
    *existeFuncion
    *E::nombre: nombre de la funcion a comprobar su existencia
    *S::Valor booleano que indica la existencia de una funcion
    *R::el nombre de la funcion debe ser un string
    *O::comprobar si una funcion ya fue definidas
    */
    private Boolean existeFuncion(String nombre){
        for(Funcion funcion : functions){
            if(funcion.getName() == nombre){
                return true;
            }
        }
        return false;
    }

    /*
    *getSymbolTableStack
    *E::ninguna
    *S::Tablas de simbolos que han sido creadas
    *R::ningua
    *O::Retornar las tablas de simbolos que han sido creadas
    */
    public SymbolTableStack getSymbolTableStack() {
        return symbolTables;
    }

    
    /*
    *getErrores
    *E::ningua
    *S::valor booleano que indica la existencia de algun error
    *R::ninguna
    *O::indicar si durante el parseo se encontro algun error
    */
    public Boolean getErrores(){
        return errores;
    }

    //instancia del analizador lexico creado en jflex
    Analizador s;
    parser(Analizador s){ this.s=s; }
:}

scan with {: return s.next_token(); :};

/*---------------------------declaraciones------------------------*/

terminal REXC, OR, AND, MULT, LPAREN , RPAREN, MENOS, MAS, ASIG, LBRACKET, RBRACKET, LBRACE, RBRACE, 
    COMA, MENOR, MAYOR, DIV, MENORIGUAL, MAYORIGUAL, EQUAL, NOTEQUAL, POTENCIA, MODULO, INCREMENTO, 
    DECREMENTO, NOT, IF, ELIF, ELSE, WHILE, DO, FOR, RETURN, BREAK, LEER, ESCRIBIR, uminus;

terminal String LITERAL_INT, LITERAL_FLOAT, LITERAL_BOOL, LITERAL_CHAR, LITERAL_STRING;
terminal String IDENTIFIER, DOLLAR, INT, FLOAT, STRING, CHAR, ARRAY, BOOL,MAIN;

non terminal  inicio, programa, main, funciones,expresion, opRelacional, operadorArit, 
    operadorUnario, operadorLogico, expresionAritmetica, expresionRelacional, expresionLogica, 
    expresionRelLog, terminoLogico, operandoArit, operandoRel, array, if, elif, while, doWhile, 
    for, estructuraControl, return, break, argumentos, llamaFuncion, asignacion, sentencia, bloque, 
    parametros, declaraFuncion,tipo, declaraArray, declaraArrayAux, declaraVar, declaraVarNoAsig, getValorArray, 
    setValorArray, lectura, numerico, escritura, literales, argumento,  else, bloqueFunc;


//declaraciones de precedencia
precedence left MAS, MENOS;
precedence left MULT, DIV;
precedence right uminus;
precedence left  POTENCIA, MODULO;
precedence left AND, OR;
precedence nonassoc NOT, REXC;
precedence left DOLLAR;
precedence left CHAR, INT;
precedence left IDENTIFIER;
precedence left LPAREN,LBRACKET;
precedence left expresionLogica;
precedence left expresionRelacional;

//punto de entrada al analisis
start with inicio;

inicio ::= programa:e {:System.out.println("El programa ha sido parseado de manera exitosa"); RESULT = new Node("inicio",new Node[]{(Node)e}); :};


programa ::= main:e {: RESULT = new Node("programa",new Node[]{(Node)e});:}
    | funciones:f main:m {:RESULT = new Node("programa", new Node[]{(Node)f, (Node)m});:}
    | main:m funciones:f {:RESULT = new Node("programa", new Node[]{(Node)m, (Node)f});:}
    | funciones:f main:m funciones:e {:RESULT = new Node("programa", new Node[]{(Node)f, (Node)m, (Node)e});:}
    ;


main ::= INT:t MAIN:e LPAREN RPAREN LBRACE bloque:d RBRACE 
    {: 
        Boolean existe = false;
        for (Funcion f : functions) {
            if (f.getName().equals(e) && f.getTipoRetorno().equals((String) t )){
                System.out.println("La funcion "+ (String) t +"  " + e + " ya fue declarada");
                errores = true;
                existe = true;
            }
        }
        if(existe == false){
            Funcion newFuncion = new Funcion(e, listaParametros.getParams(), (String) t);
            functions.add(newFuncion);

            SymbolTable symbolTable = new SymbolTable(e,(String) t);

            for (ElementoTabla param : listaParametros.getParams()) {
                symbolTable.addSymbol(param.getName(), param.getType());
            }
            for (ElementoTabla par : listaVariables.getParams()) {
                if (symbolTable.containsSymbol( par.getName())) {
                    System.out.println("El simbolo " +  par.getName() + " ya fue declarado en esta funci√≥n");
                    errores = true;
                }else{
                    symbolTable.addSymbol(par.getName(), par.getType());
                }
            }
             getSymbolTableStack().push(symbolTable);  
        }
        listaVariables  = new ListaElementosTabla();
        listaParametros  = new ListaElementosTabla();
        RESULT = new Node("main",new Node[] {new Node((String)t), new Node(e), new Node("("), new Node(")"), new Node("{"), (Node)d, new Node("}")});
    :};

funciones ::= funciones:f declaraFuncion:d {: RESULT = new Node("funciones",new Node[]{(Node)f,(Node)d});:}
    | declaraFuncion:d {: RESULT = new Node("funciones",new Node[]{(Node)d});:}
    ;


expresion ::= expresionLogica:e {:RESULT = new Node("expresion",new Node[]{(Node)e});:}
    |expresionAritmetica:e {:RESULT = new Node("expresion",new Node[]{(Node)e});:}
    ;


operadorArit::= MAS:e {:RESULT = new Node("operadorArit", new Node[] {new Node((String)e)});:}
    | MENOS:e {:RESULT = new Node("operadorArit", new Node[] {new Node((String)e)});:}
    | MULT :e {:RESULT = new Node("operadorArit", new Node[] {new Node((String)e)});:}
    | POTENCIA :e {:RESULT = new Node("operadorArit", new Node[] {new Node((String)e)});:}
    | DIV :e {:RESULT = new Node("operadorArit", new Node[] {new Node((String)e)});:}
    | MODULO:e {:RESULT = new Node("operadorArit", new Node[] {new Node((String)e)});:}
    ;


opRelacional ::= MENOR
    | MENORIGUAL
    | MAYOR
    | MAYORIGUAL
    | EQUAL 
    | NOTEQUAL 
    ;


operadorUnario ::= MENOS numerico  %prec uminus
    | INCREMENTO IDENTIFIER 
    | DECREMENTO IDENTIFIER
    ;


operadorLogico ::= AND
    |OR 
    |REXC
    //|NOT
    ;


expresionAritmetica ::= operandoArit:e {:RESULT = new Node("expresionAritmetica",new Node[]{(Node) e});:}
    | expresionAritmetica:ex operadorArit:op operandoArit:e 
    {:
        //String primerOperando  = ((Node)ex).getSymbol();
        //String segundoOperando = ((Node)e).getSymbol();
        //if(primerOperando == "int" || primerOperando == "float"){
        //    if(segundoOperando == "int" || segundoOperando == "float"){
        //        System.out.println("operacion correcta ");
                RESULT = new Node(((Node)op).getChildren()[0].getSymbol(),new Node[]{(Node) ex, (Node)e});
        //    }
        //}else if(primerOperando == "string" || primerOperando == "char"){
        //    if(segundoOperando == "string" || segundoOperando == "char"){
        //        System.out.println("operacion correcta ");
        //        RESULT = new Node("expresionAritmetica",new Node[]{(Node) ex,(Node)op, (Node)e});
        //    }
        //}else{
        //    System.out.println("No se puede llevar a cabo la operacion "+primerOperando.+" "+((Node)op).getSymbol()+" "+segundoOperando );
        //}
    :}
    ;





expresionRelacional ::= operandoRel opRelacional operandoRel ;


expresionLogica ::= terminoLogico:t {:RESULT = new Node("expresionLogica", new Node[]{(Node) t});:}
    | expresionLogica operadorLogico terminoLogico
    ;


terminoLogico ::= LITERAL_BOOL:b {:RESULT = new Node("terminoLogico", new Node[]{new Node((String) b)});:}
    | LPAREN expresionRelacional RPAREN
    | expresionRelacional
    | NOT terminoLogico
    ;


operandoArit ::= IDENTIFIER
    | LITERAL_STRING:e {:
        System.out.println("literal_string");
        System.out.println(e);
        RESULT = new Node("operandoArit",new Node[]{new Node((String) e)});
    :}
    | LITERAL_INT:e {:
        System.out.println("literal_int");
        System.out.println(e);
        RESULT = new Node("operandoArit",new Node[]{new Node((String) e)});
        :}    
    | LITERAL_FLOAT:e {:
        RESULT = new Node("operandoArit",new Node[]{new Node((String) e)});
        :} 
    | LITERAL_CHAR:e {:
        RESULT = new Node("operandoArit",new Node[]{new Node((String) e)});
        :}    
    | llamaFuncion   
    | operadorUnario 
    | LBRACKET array RBRACKET
    | getValorArray
    | LPAREN expresionAritmetica RPAREN
    ;


operandoRel ::= operandoArit 
    | LITERAL_BOOL:b {:RESULT = new Node("operandoRel", new Node[]{new Node((String) b)});:}
    ;


literales ::= LITERAL_INT
    |LITERAL_FLOAT
    |LITERAL_BOOL
    |LITERAL_STRING
    |LITERAL_CHAR
    |LBRACKET array RBRACKET
    ;


array ::= expresion  
    | array COMA expresion
    ;


if ::= IF LPAREN expresionRelLog RPAREN LBRACE bloque RBRACE 
    ;


elif ::= ELIF LPAREN expresionRelLog RPAREN LBRACE bloque RBRACE
    | elif ELIF LPAREN expresionRelLog RPAREN LBRACE bloque RBRACE
    ;


else ::= ELSE LBRACE bloque RBRACE;


while ::= WHILE LPAREN expresionRelLog RPAREN LBRACE bloque RBRACE 
    ;


doWhile ::= DO LBRACE bloque RBRACE WHILE LPAREN expresionRelLog RPAREN DOLLAR 
    ;


for ::= FOR LPAREN declaraVar DOLLAR expresionRelLog DOLLAR expresion  RPAREN LBRACE bloque RBRACE 
    ;


estructuraControl ::= if
    |if elif
    |if elif else
    |if  else
    |while
    |doWhile 
    |for
    ;


return ::= RETURN expresion
    |RETURN:r {:RESULT = new Node(r):}
    ;


break ::= BREAK;


argumento ::= IDENTIFIER
    | literales
    ;


argumentos ::= argumento
    | argumentos COMA expresion
    ;


llamaFuncion ::= IDENTIFIER  LPAREN RPAREN
    | IDENTIFIER LPAREN argumentos RPAREN 
    | lectura
    | escritura 
    ;


asignacion ::= IDENTIFIER:e ASIG expresion ;


sentencia ::= asignacion DOLLAR 
    | estructuraControl 
    | expresion DOLLAR 
    | declaraArray DOLLAR 
    | declaraVar:a DOLLAR {:RESULT = new Node("sentencia",new Node[]{(Node)a,new Node("$")});:}
    | declaraVarNoAsig:a DOLLAR {:RESULT = new Node("sentencia",new Node[]{(Node)a,new Node("$")});:}
    | return:a DOLLAR {:RESULT = new Node("sentencia",new Node[]{(Node)a,new Node("$")});:}
    | break DOLLAR
    | getValorArray DOLLAR 
    | setValorArray DOLLAR
    | error DOLLAR {: System.out.println("##### Se ha encontrado un error de syntaxis, el parseo continuara"); 
        errores = true;:}
    ;


bloque ::= sentencia:s {:RESULT = new Node("bloque",new Node[]{(Node)s});:}
    | bloque:b sentencia:s {:
        System.out.println("bloque");
        RESULT = new Node("bloque",new Node[]{(Node)b,(Node)s});:}
    ;


parametros ::= tipo:t IDENTIFIER:i {: listaParametros.addParameter(new ElementoTabla(i,(String) t));:}
    | parametros:p COMA tipo:t IDENTIFIER:i {:listaParametros.addParameter(new ElementoTabla(i,(String) t));:}
    ;


declaraFuncion ::= tipo:t IDENTIFIER:e LPAREN parametros RPAREN LBRACE bloqueFunc RBRACE 
    {:
        Boolean existe = false;
        for (Funcion f : functions) {
            if (f.getName().equals(e) && f.getTipoRetorno().equals((String) t)) {
                System.out.println("La funcion "+ (String) t +"  " + e + " ya fue declarada");
                errores = true;
                existe = true;
            }
        }
        if(existe == false){
            Funcion newFuncion = new Funcion(e, listaParametros.getParams(), (String) t);
            functions.add(newFuncion);

            SymbolTable symbolTable = new SymbolTable(e,(String) t);

            for (ElementoTabla param : listaParametros.getParams()) {
                symbolTable.addSymbol(param.getName(), param.getType());
            }
            for (ElementoTabla par : listaVariables.getParams()) {
                if (symbolTable.containsSymbol( par.getName())) {
                    System.out.println("Symbolo " +  par.getName() + " ya ha sido declarado en esta funcion");
                    errores = true;
                }else{
                    symbolTable.addSymbol(par.getName(), par.getType());
                }
            }
             getSymbolTableStack().push(symbolTable);
        }
        listaVariables  = new ListaElementosTabla();
        listaParametros  = new ListaElementosTabla();
       
    :}

    | tipo:t IDENTIFIER:e LPAREN RPAREN LBRACE bloque:b RBRACE
    {:
        
        Boolean existe = false;
        for (Funcion f : functions) {
            if (f.getName().equals(e) && f.getTipoRetorno().equals((String) t)) {
                System.out.println("La funcion \""+ (String) t +"  " + e + "\" ya fue declarada previamente");
                errores = true;
                existe = true;
            }
        }
        if(existe == false){
            Funcion newFuncion = new Funcion(e, listaParametros.getParams(), (String) t);
            functions.add(newFuncion);

            SymbolTable symbolTable = new SymbolTable(e,(String) t);

            for (ElementoTabla param : listaParametros.getParams()) {
                symbolTable.addSymbol(param.getName(), param.getType());
            }
            for (ElementoTabla par : listaVariables.getParams()) {
                if (symbolTable.containsSymbol( par.getName())) {
                    System.out.println("Symbolo " +  par.getName() + " ya ha sido declarado en esta funcion");
                    errores = true;
                }else{
                    symbolTable.addSymbol(par.getName(), par.getType());
                }
            }
             getSymbolTableStack().push(symbolTable);
        }
        listaVariables  = new ListaElementosTabla();
        listaParametros  = new ListaElementosTabla();
        RESULT = new Node( "declaraFuncion", new Node[]{new Node((String)t), new Node(e), new Node("null"), (Node)b });
       
    :};


bloqueFunc ::= bloque;


tipo ::= INT:e {:RESULT = e;:}
    | CHAR:e {: RESULT = e;:}
    |FLOAT:e {:  RESULT = e;:}
    |STRING:e {: RESULT = e;:}
    |ARRAY:e {:  RESULT = e;:}
    |BOOL:e {: RESULT = e; :}
    ;


declaraArray ::=  INT IDENTIFIER LBRACKET LITERAL_INT RBRACKET
    |   CHAR IDENTIFIER LBRACKET LITERAL_INT RBRACKET
    ;


declaraArrayAux ::= LBRACKET LITERAL_INT RBRACKET
    ;

declaraVarNoAsig ::= INT:t IDENTIFIER:i {:
            listaVariables.addParameter(new ElementoTabla(i,(String) t));
            RESULT = new Node("declaraVarNoAsig", new Node[]{new Node((String)t),new Node(i)});
        :}  
    | CHAR:t IDENTIFIER:i {:
            listaVariables.addParameter(new ElementoTabla(i,(String) t));
            RESULT = new Node("declaraVarNoAsig", new Node[]{new Node((String)t),new Node(i)});
        :}
    | tipo:t IDENTIFIER:i declaraArrayAux {:
            listaVariables.addParameter(new ElementoTabla(i,(String) t));
            RESULT = new Node("declaraVarNoAsig", new Node[]{new Node((String)t),new Node(i)});
        :}
    | tipo:t IDENTIFIER:i  {:
            listaVariables.addParameter(new ElementoTabla(i,(String) t));
            RESULT = new Node("declaraVarNoAsig", new Node[]{new Node((String)t),new Node(i)});
        :}
    ;

declaraVar ::= 
       INT:t IDENTIFIER:i ASIG expresion:e {:
           listaVariables.addParameter(new ElementoTabla(i,(String) t));
           System.out.println("declara int = ");
           System.out.println(((Node)e).getSymbol());
           RESULT = new Node("declaraVar", new Node[]{new Node((String)t),new Node(i),new Node("="),(Node)e});
       :}  
    |
    CHAR:t IDENTIFIER:i  ASIG expresion:e {:
            listaVariables.addParameter(new ElementoTabla(i,(String) t));
            System.out.println("declara char");
            RESULT = new Node("declaraVar", new Node[]{new Node((String)t),new Node(i),new Node("="),(Node)e});
        :}
    | tipo:t IDENTIFIER:i declaraArrayAux ASIG expresion{:
            listaVariables.addParameter(new ElementoTabla(i,(String) t));
        :}
    | tipo:t IDENTIFIER:i ASIG expresion:e {:
            listaVariables.addParameter(new ElementoTabla(i,(String) t));
            RESULT = new Node("declaraVar", new Node[]{new Node((String)t),new Node(i),new Node("="),(Node)e});
        :}
    ;


getValorArray ::= IDENTIFIER declaraArrayAux 
    ;


setValorArray ::= getValorArray ASIG expresion   ;


lectura ::= LEER LPAREN numerico RPAREN ;


numerico ::= LITERAL_INT | LITERAL_FLOAT  ;


escritura ::= ESCRIBIR LPAREN expresion RPAREN ; 


